use proc_macro::TokenStream;
use quote::quote;
use syn::{parse::Parse, parse_macro_input, Expr, LitStr, Token};

struct RegisterArgs {
    name: LitStr,
    _comma: Token![,],
    expr: Expr,
}

impl Parse for RegisterArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        Ok(Self {
            name: input.parse()?,
            _comma: input.parse()?,
            expr: input.parse()?,
        })
    }
}

/// register_index_engine!("name", FactoryExpr());
/// Expands to:
/// pub fn register() {
///   fn __factory() -> Box<dyn crate::IndexEngine> { Box::new(FactoryExpr()) }
///   crate::register_engine("name", __factory);
/// }
#[proc_macro]
pub fn register_index_engine(input: TokenStream) -> TokenStream {
    let RegisterArgs { name, expr, .. } = parse_macro_input!(input as RegisterArgs);

    let expanded = quote! {
        #[doc = "Generated by gurt_macros::register_index_engine"]
        pub fn register() {
            fn __factory() -> Box<dyn crate::IndexEngine> {
                Box::new(#expr)
            }
            crate::register_engine(#name, __factory);
        }
    };

    TokenStream::from(expanded)
}

// Usage: #[route(method = "GET", path = "/api/search")] on a wrapper fn.
// Generates a sibling `<fn_name>__register()` that registers the route in gurt_web.

struct RouteArgs {
    method: LitStr,
    path: LitStr,
    key: Option<LitStr>,
}

impl Parse for RouteArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut method: Option<LitStr> = None;
        let mut path: Option<LitStr> = None;
        let mut key: Option<LitStr> = None;
        while !input.is_empty() {
            let ident: syn::Ident = input.parse()?;
            input.parse::<Token![=]>()?;
            let val: LitStr = input.parse()?;
            if ident == "method" {
                method = Some(val);
            } else if ident == "path" {
                path = Some(val);
            } else if ident == "key" {
                key = Some(val);
            } else {
                return Err(syn::Error::new(ident.span(), "unknown argument"));
            }
            let _ = input.parse::<Token![,]>().ok();
        }
        Ok(Self {
            method: method
                .ok_or_else(|| syn::Error::new(proc_macro2::Span::call_site(), "missing method"))?,
            path: path
                .ok_or_else(|| syn::Error::new(proc_macro2::Span::call_site(), "missing path"))?,
            key,
        })
    }
}

#[proc_macro_attribute]
pub fn route(args: TokenStream, item: TokenStream) -> TokenStream {
    let RouteArgs { method, path, key } = parse_macro_input!(args as RouteArgs);

    let func = parse_macro_input!(item as syn::ItemFn);
    let fn_ident = func.sig.ident.clone();
    let register_ident = syn::Ident::new(&format!("{}__register", fn_ident), fn_ident.span());
    let key_str = key.unwrap_or_else(|| LitStr::new(&fn_ident.to_string(), fn_ident.span()));

    let expanded = quote! {
        #func

        #[doc = "Generated by gurt_macros::route"]
        pub fn #register_ident() {
            gurt_web::register_route(#method, #path, #key_str);
        }
    };

    TokenStream::from(expanded)
}
